#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "../include/stb_image.h"
#include "../include/stb_image_write.h"

// Modular exponentiation
uint32_t mod_exp(uint32_t base, uint32_t exp, uint32_t mod) {
    uint64_t result = 1;
    uint64_t base_mod = base % mod;
    while (exp > 0) {
        if (exp & 1) {
            result = (result * base_mod) % mod;
        }
        base_mod = (base_mod * base_mod) % mod;
        exp >>= 1;
    }
    return (uint32_t)result;
}

// Extended Euclidean Algorithm to find modular inverse
int32_t mod_inv(int32_t a, int32_t m) {
    int32_t m0 = m, t, q;
    int32_t x0 = 0, x1 = 1;

    if (m == 1) return 0;

    while (a > 1) {
        q = a / m;
        t = m;
        m = a % m;
        a = t;

        t = x0;
        x0 = x1 - q * x0;
        x1 = t;
    }
    if (x1 < 0) x1 += m0;
    return x1;
}

// ElGamal Parameters
const uint32_t P = 30803;  // prime
const uint32_t G = 2;      // generator
const uint32_t X = 7897;   // private key < P
uint32_t Y;                // public key = G^X mod P

// Initialize public key Y
void elgamal_init() {
    Y = mod_exp(G, X, P);
}

// Simple checksum hash of image data
uint32_t simple_hash(uint8_t *data, int len) {
    uint32_t hash = 0;
    for (int i = 0; i < len; i++) {
        hash = (hash + data[i]) % P;
    }
    return hash;
}

// ElGamal digital signature generation (simplified)
// input: message hash, output: signature (r,s)
void elgamal_sign(uint32_t hash, uint32_t *r, uint32_t *s) {
    uint32_t k = 12345; // should be random and gcd(k,P-1)=1, simplified here
    uint32_t k_inv = mod_inv(k, P - 1);

    *r = mod_exp(G, k, P);
    *s = (k_inv * (hash + X * (*r))) % (P - 1);
}

// ElGamal signature verification
int elgamal_verify(uint32_t hash, uint32_t r, uint32_t s) {
    if (r <= 0 || r >= P) return 0;
    uint32_t v1 = (mod_exp(Y, r, P) * mod_exp(r, s, P)) % P;
    uint32_t v2 = mod_exp(G, hash, P);
    return v1 == v2;
}

// Print uint8_t matrix
void print_matrix_uint8(uint8_t *data, int width, int height, const char *label) {
    printf("\n%s (First 10x10 pixels):\n", label);
    for (int i = 0; i < 10 && i < height; i++) {
        for (int j = 0; j < 10 && j < width; j++) {
            printf("%4d ", data[i * width + j]);
        }
        printf("\n");
    }
}

// OFB Mode encryption/decryption for image data
// keystream generated by repeated ElGamal exponentiation starting from IV
void elgamal_ofb_encrypt_decrypt(uint8_t *input, uint8_t *output, int size, uint32_t iv) {
    uint32_t feedback = iv;
    for (int i = 0; i < size; i++) {
        // Generate next keystream byte: feedback = g^feedback mod p
        feedback = mod_exp(G, feedback, P);
        uint8_t keystream_byte = (uint8_t)(feedback & 0xFF);
        output[i] = input[i] ^ keystream_byte;
    }
}

int main() {
    int w, h, ch;

    elgamal_init();

    // Load grayscale image
    uint8_t *img = stbi_load("../images/input1.bmp", &w, &h, &ch, 1);
    if (!img) {
        printf(" Failed to load input1.bmp\n");
        return 1;
    }
    int size = w * h;

    print_matrix_uint8(img, w, h, "Original Image Matrix");

    // Compute simple hash of original image for signature
    uint32_t hash = simple_hash(img, size);

    // Generate digital signature
    uint32_t r, s;
    elgamal_sign(hash, &r, &s);
    printf("\nDigital Signature (r, s): (%u, %u)\n", r, s);

    // Encrypt image with OFB mode (using IV = 1 for demo)
    uint8_t *encrypted = (uint8_t *)malloc(size);
    if (!encrypted) {
        printf(" Memory allocation failed\n");
        stbi_image_free(img);
        return 1;
    }
    elgamal_ofb_encrypt_decrypt(img, encrypted, size, 1);

    stbi_write_bmp("../images/encrypted_ofb_elgamal.bmp", w, h, 1, encrypted);
    print_matrix_uint8(encrypted, w, h, "Encrypted Image Matrix");

    // Decrypt image with OFB mode (IV must match)
    uint8_t *decrypted = (uint8_t *)malloc(size);
    if (!decrypted) {
        printf(" Memory allocation failed\n");
        free(encrypted);
        stbi_image_free(img);
        return 1;
    }
    elgamal_ofb_encrypt_decrypt(encrypted, decrypted, size, 1);
    stbi_write_bmp("../images/decrypted_ofb_elgamal.bmp", w, h, 1, decrypted);
    print_matrix_uint8(decrypted, w, h, "Decrypted Image Matrix");

    // Verify signature on decrypted image hash
    uint32_t decrypted_hash = simple_hash(decrypted, size);
    int valid = elgamal_verify(decrypted_hash, r, s);
    printf("\nSignature verification on decrypted image: %s\n", valid ? "VALID" : "INVALID");

    // Cleanup
    stbi_image_free(img);
    free(encrypted);
    free(decrypted);

    printf("\n ElGamal OFB mode with Digital Signature demo complete.\n");
    return 0;
}
